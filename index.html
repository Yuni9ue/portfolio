<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Projects | 신종윤 포트폴리오</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap');
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #f8fafc; /* bg-slate-50 */
        }
        .nav-tab {
            padding: 0.75rem 1.5rem;
            font-size: 0.875rem; /* text-sm */
            font-weight: 500; /* medium */
            color: #4338ca; /* text-indigo-700 */
            background-color: #ffffff;
            border: 1px solid #e0e7ff; /* border-indigo-100 */
            border-radius: 0.5rem; /* rounded-lg */
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }
        .nav-tab:hover {
            background-color: #f0f9ff; /* bg-sky-50 */
        }
        .nav-tab.active-tab {
            background-color: #4338ca; /* bg-indigo-700 */
            color: #ffffff;
            font-weight: 700; /* bold */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }
        .project-content {
            background-color: #ffffff;
            border-radius: 0.75rem; /* rounded-xl */
            padding: 2rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -2px rgba(0, 0, 0, 0.05);
            border: 1px solid #e2e8f0; /* border-slate-200 */
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        h2 {
            font-size: 1.875rem; /* text-3xl */
            font-weight: 700; /* bold */
            color: #1e293b; /* text-slate-800 */
            margin-bottom: 0.5rem;
        }
        h3 {
            font-size: 1.125rem; /* text-lg */
            font-weight: 500; /* medium */
            color: #64748b; /* text-slate-500 */
            margin-bottom: 1.5rem;
        }
        h4 {
            font-size: 1.25rem; /* text-xl */
            font-weight: 700; /* bold */
            color: #334155; /* text-slate-700 */
            margin-top: 2rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #e0e7ff; /* border-indigo-100 */
            padding-bottom: 0.5rem;
        }
        ul {
            list-style-type: disc;
            padding-left: 1.5rem;
            margin-bottom: 1rem;
            color: #334155; /* text-slate-700 */
        }
        li {
            margin-bottom: 0.5rem;
        }
        .tech-tag {
            display: inline-block;
            background-color: #eef2ff; /* bg-indigo-50 */
            color: #3730a3; /* text-indigo-800 */
            padding: 0.25rem 0.75rem;
            border-radius: 9999px; /* rounded-full */
            font-size: 0.875rem; /* text-sm */
            font-weight: 500; /* medium */
            margin-right: 0.5rem;
            margin-bottom: 0.5rem;
        }
        .stat-card {
            background-color: #f0fdf4; /* bg-green-50 */
            border-left: 4px solid #22c55e; /* border-green-500 */
            padding: 1rem;
            border-radius: 0.5rem; /* rounded-lg */
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.05);
        }
        .stat-value {
            font-size: 2.25rem; /* text-4xl */
            font-weight: 700; /* bold */
            color: #15803d; /* text-green-700 */
        }
        .stat-label {
            font-size: 0.875rem; /* text-sm */
            font-weight: 500; /* medium */
            color: #166534; /* text-green-800 */
            margin-top: 0.25rem;
        }
        .reflection-box {
            background-color: #fdfbf6;
            border: 1px solid #fde68a; /* border-amber-200 */
            border-radius: 0.5rem; /* rounded-lg */
            padding: 1.5rem;
            margin-top: 1.5rem;
        }
        .reflection-box h5 {
            font-size: 1rem; /* text-base */
            font-weight: 700; /* bold */
            color: #b45309; /* text-amber-700 */
            margin-bottom: 0.75rem;
        }
        .reflection-box p, .reflection-box li {
            color: #92400e; /* text-amber-900 */
            font-size: 0.9rem; /* text-sm 보다 조금 크게 */
            line-height: 1.6;
        }
        .project-section-list {
            list-style-type: none;
            padding-left: 0;
        }
        .project-section-list > li {
            background-color: #f9fafb; /* bg-slate-50 */
            border: 1px solid #e5e7eb; /* border-gray-200 */
            border-radius: 0.5rem; /* rounded-lg */
            padding: 1rem;
            margin-bottom: 1rem;
        }
        .project-section-list strong {
            color: #1d4ed8; /* text-blue-700 */
            font-weight: 700;
        }
        .project-section-list .part-title {
            font-size: 1.125rem; /* text-lg */
            font-weight: 700;
            color: #1e3a8a; /* text-blue-800 */
        }
        .project-section-list .part-desc {
            font-size: 0.875rem; /* text-sm */
            color: #4b5563; /* text-gray-600 */
            margin-bottom: 0.75rem;
        }
    </style>
</head>
<body class="bg-slate-50">

    <div class="max-w-5xl mx-auto p-4 sm:p-6 lg:p-8">
        <!-- 헤더 -->
        <header class="text-center mb-10">
            <h1 class="text-4xl sm:text-5xl font-bold text-slate-900 mb-3">Projects</h1>
            <p class="text-lg text-slate-600 max-w-2xl mx-auto">
                컴퓨터 공학의 핵심 원리를 깊이 있게 탐구하고 적용한 프로젝트들입니다. 대용량 데이터 처리, 네트워크 프로토콜 구현, 그리고 논리형 프로그래밍을 통해 문제 해결 역량을 길렀습니다.
            </p>
        </header>

        <!-- 탭 네비게이션 -->
        <nav class="flex flex-col sm:flex-row justify-center space-y-3 sm:space-y-0 sm:space-x-4 mb-8">
            <button id="tab-btn-1" data-tab="1" class="nav-tab active-tab">
                1. DB 성능 평가
            </button>
            <button id="tab-btn-2" data-tab="2" class="nav-tab">
                2. 네트워크 프로그래밍
            </button>
            <button id="tab-btn-3" data-tab="3" class="nav-tab">
                3. Prolog 에이전트
            </button>
        </nav>

        <!-- 메인 컨텐츠 영역 -->
        <main>
            <!-- 프로젝트 1: DB 성능 평가 -->
            <section id="content-1" class="project-content">
                <h2>TPC-H 벤치마크를 이용한 데이터베이스 성능 평가</h2>
                <h3>100GB 규모의 TPC-H 벤치마크 데이터를 생성하여, RDBMS와 NoSQL 데이터베이스 시스템 간의 성능을 비교 분석한 팀 프로젝트입니다.</h3>
                
                <p class="text-sm text-slate-500 mb-4">
                    <span class="font-medium">프로젝트 기간:</span> 202X.XX ~ 202X.XX (팀 프로젝트)
                </p>

                <h4>🛠️ 사용 기술 스택</h4>
                <div>
                    <span class="tech-tag">PostgreSQL</span>
                    <span class="tech-tag">MySQL</span>
                    <span class="tech-tag">Cassandra</span>
                    <span class="tech-tag">MongoDB</span>
                    <span class="tech-tag">AWS EC2</span>
                    <span class="tech-tag">Ubuntu OS</span>
                    <span class="tech-tag">TPC-H (DBGEN)</span>
                    <span class="tech-tag">cassandra.yaml</span>
                    <span class="tech-tag">my.cnf</span>
                    <span class="tech-tag">nodetool</span>
                </div>

                <h4>🚀 주요 활동 및 문제 해결 경험</h4>
                <ol class="project-section-list list-decimal list-inside text-slate-700 space-y-4">
                    <li>
                        <strong>1. 인프라 구축 및 확장 (AWS EC2)</strong>
                        <ul class="mt-2">
                            <li><strong>문제:</strong> 초기 단일 EC2 인스턴스(`t3a.xlarge`) 환경에서 100GB 데이터 처리 시, 컴퓨팅 자원 부족 문제에 직면했습니다.</li>
                            <li><strong>해결:</strong> 4개의 EC2 인스턴스로 확장하고, 인스턴스 사양을 `c5.4xlarge` 등으로 업그레이드하여 안정적인 테스트 환경을 구축했습니다.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>2. Cassandra Multi-Node 클러스터 구축</strong>
                        <ul class="mt-2">
                            <li><strong>목표:</strong> 데이터베이스 확장성(Scalability)을 실증적으로 분석하기 위해 4-Node Cassandra 클러스터를 구축했습니다.</li>
                            <li><strong>과정:</strong> 
                                <ul class="list-disc list-inside ml-4 mt-1">
                                    <li>AWS 보안 그룹에서 클라이언트 포트(9042) 및 노드 간 통신 포트(7000)를 개방했습니다.</li>
                                    <li>`cassandra.yaml` 설정 파일에서 Seed 노드 IP를 지정하고 노드 간 `listen_address`를 설정하여 클러스터를 구성했습니다.</li>
                                    <li>`nodetool status` 명령어를 사용해 4개 노드가 모두 정상(Status=UN) 연결되었는지 확인했습니다.</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>3. MongoDB 성능 이슈 분석 및 스키마 재설계</strong>
                        <ul class="mt-2">
                            <li><strong>문제:</strong> MongoDB 환경에서 복잡한 TPC-H 쿼리 실행 시 'broken pipe' 및 'MaxTimeMSExpired' (4시간 이상 초과) 오류가 발생하며 쿼리가 실패했습니다.</li>
                            <li><strong>가설:</strong> 정규화된 SQL 스키마를 그대로 MongoDB에 로드하여, 쿼리 수행 시 과도한 `$lookup` (SQL의 JOIN) 연산이 발생한 것을 원인으로 진단했습니다.</li>
                            <li><strong>시도:</strong> MongoDB의 Document 모델에 최적화하기 위해, 'supplier' 내부에 'nation'과 'region' 정보를 내장(Embedding)하는 비정규화(Denormalization) 스키마로 데이터를 재설계했습니다.</li>
                            <li><strong>결론:</strong> 스키마를 개선했음에도 쿼리 타임아웃이 재발생했으며, 이를 통해 TPC-H 벤치마크의 복잡한 관계형 조인 쿼리는 MongoDB의 Aggregation Framework에 부적합하다는 결론을 도출했습니다.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>4. MySQL 성능 튜닝 (후속 연구)</strong>
                        <ul class="mt-2">
                            <li><strong>문제:</strong> 100GB 데이터 로드 및 쿼리 중 서버 다운 등 불안정 문제가 발생하여, 초기 튜닝 시도(버퍼 풀 조정)가 유의미한 결과를 내지 못했습니다.</li>
                            <li><strong>재시도:</strong> 10GB 데이터셋으로 환경을 재구성하여, `my.cnf` 파일의 `innodb_buffer_pool_size` (1G, 26G, 29G) 값을 변경하며 성능을 테스트했습니다.</li>
                            <li><strong>결과:</strong> 버퍼 풀 크기를 1GB에서 26/29GB로 늘리자, 대규모 디스크 I/O를 유발하는 쿼리(Q17, Q20)의 실행 시간이 각각 <strong>1/3, 1/4 수준으로 단축</strong>되는 것을 확인했습니다.</li>
                            <li><strong>결론:</strong> 대용량 데이터 처리 시, 충분한 버퍼 풀 메모리 확보를 통한 디스크 I/O 감소가 성능 향상에 핵심적임을 입증했습니다.</li>
                        </ul>
                    </li>
                </ol>

                <h4>📊 프로젝트 핵심 성과</h4>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 my-6">
                    <div class="stat-card">
                        <div class="stat-value">67.95%</div>
                        <div class="stat-label">Cassandra Multi-Node 쿼리 시간 단축</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">최대 4배</div>
                        <div class="stat-label">MySQL 튜닝(Buffer Pool) 성능 향상</div>
                    </div>
                </div>
                <ul>
                    <li><strong>Cassandra 확장성 입증:</strong> Cassandra Multi-node(4대) 구성은 Single-node 대비 <strong>전체 쿼리 실행 시간을 67.95% 단축</strong>시켰습니다. 이는 병렬 처리 및 분산 아키텍처의 효율성을 명확하게 보여줍니다.</li>
                    <li><strong>RDBMS vs NoSQL 특성 비교:</strong>
                        <ul class="list-disc list-inside ml-4 mt-1">
                            <li><strong>RDBMS (PostgreSQL, MySQL):</strong> TPC-H의 복잡한 조인 및 집계 쿼리 실행에 강점을 보였습니다.</li>
                            <li><strong>NoSQL (Cassandra, MongoDB):</strong> Cassandra는 분산 환경의 병렬 처리 및 특정 필터링/집계 쿼리에 강점을 보였으나, MongoDB는 복잡한 관계형 쿼리 실행에 실패하며 한계를 보였습니다.</li>
                        </ul>
                    </li>
                </ul>
            </section>
            
            <!-- ########################################## -->
            <!-- 프로젝트 2: 네트워크 프로그래밍 (수정된 섹션) -->
            <!-- ########################################## -->
            <section id="content-2" class="project-content hidden">
                <h2>TCP/UDP 기반 네트워크 응용 프로그램</h2>
                <h3>[1부] 기본 채팅부터 [2부] 신뢰성 있는 파일 전송(RDT), [3부] 네트워크 스캐너 기능까지 단계별로 구현한 네트워크 응용 프로그램 개발 프로젝트입니다.</h3>
                
                <p class="text-sm text-slate-500 mb-4">
                    <span class="font-medium">프로젝트 기간:</span> 202X.XX ~ 202X.XX (팀 프로젝트)
                </p>

                <h4>🛠️ 사용 기술 스택</h4>
                <div>
                    <span class="tech-tag">Python</span>
                    <span class="tech-tag">socket</span>
                    <span class="tech-tag">scapy</span>
                    <span class="tech-tag">TCP/IP</span>
                    <span class="tech-tag">UDP</span>
                    <span class="tech-tag">ARP</span>
                    <span class="tech-tag">Sliding Window</span>
                    <span class="tech-tag">RDT</span>
                    <span class="tech-tag">Windows</span>
                    <span class="tech-tag">macOS</span>
                </div>

                <h4>📜 주요 구현 내용 (3-Parts)</h4>
                <ol class="project-section-list list-decimal list-inside text-slate-700 space-y-4">
                    <li>
                        <div class="part-title">Part 1. 기본 소켓 채팅 프로그램</div>
                        <div class="part-desc">TCP/UDP 소켓 프로그래밍의 기본을 이해하고, 간단한 클라이언트-서버 채팅 GUI 프로그램을 구현했습니다.</div>
                        <ul class="list-disc list-inside ml-4">
                            <li>`socket` 라이브러리를 사용하여 TCP 서버/클라이언트 및 UDP 서버/클라이언트 소켓을 각각 생성하고 연결했습니다.</li>
                            <li>TCP (연결 지향)와 UDP (비연결 지향) 프로토콜을 통해 양방향 텍스트 메시지 송수신 기능을 구현했습니다.</li>
                        </ul>
                    </li>
                    <li>
                        <div class="part-title">Part 2. 신뢰성 있는 파일 전송 (RDT)</div>
                        <div class="part-desc">1부의 채팅 프로그램에 파일 전송 기능을 추가하고, 특히 UDP의 비신뢰성을 극복하기 위한 RDT(Reliable Data Transfer) 프로토콜을 직접 구현했습니다.</div>
                        <ul class="list-disc list-inside ml-4">
                            <li><strong>UDP 신뢰성 보장 (RDT):</strong>
                                <ul class="list-disc list-inside ml-6 mt-1">
                                    <li><strong>Sliding Window (GBN/SR):</strong> ACK 번호(`udp_ack_num`)와 패킷 시퀀스 번호(`udp_last_ack_num`)를 관리하는 슬라이딩 윈도우 메커니즘을 구현했습니다.</li>
                                    <li><strong>Timeout 및 재전송:</strong> `udp_time_out()` 함수로 ACK 수신 시간을 체크하고, 타임아웃 발생 시 `udp_pipeline()` 함수를 통해 해당 패킷을 재전송하여 데이터 유실을 방지했습니다.</li>
                                    <li><strong>패킷 버퍼링:</strong> 수신 측에서 순서가 맞지 않는 패킷을 `udp_recv_packet` 버퍼에 임시 저장하고, 연속된 패킷이 도착하면 파일에 순차적으로 쓰도록 구현했습니다.</li>
                                </ul>
                            </li>
                            <li><strong>결과:</strong> TCP와 UDP 양쪽 프로토콜로 이미지, 텍스트 파일 등을 성공적으로 전송하고, `downloads` 폴더에 저장되는 것을 확인했습니다.</li>
                        </ul>
                    </li>
                    <li>
                        <div class="part-title">Part 3. ARP 스캐너 및 모빌리티 분석</div>
                        <div class="part-desc">`scapy` 라이브러리를 활용해 ARP 스캐너를 구현하고, 네트워크 환경 이동(Mobility)에 따른 IP 주소와 ARP 테이블의 변화를 분석했습니다.</div>
                        <ul class="list-disc list-inside ml-4">
                            <li><strong>ARP 스캐너:</strong> `scapy`를 사용해 지정된 IP 대역에 ARP Request(Broadcast) 패킷을 전송하고, 수신된 ARP Reply를 분석하여 로컬 네트워크 내 활성 장치들의 IP와 MAC 주소 목록을 확보했습니다.</li>
                            <li><strong>모빌리티 분석:</strong>
                                <ul class="list-disc list-inside ml-6 mt-1">
                                    <li><strong>Case 1 (같은 장소):</strong> 동일 AP에서 재연결 시, IP 주소가 변경되지 않았으며 기존 IP-MAC 매핑을 재확인하는 ARP 요청만 관찰되었습니다.</li>
                                    <li><strong>Case 2 (장소 이동):</strong> 다른 AP로 이동하자, DHCP를 통해 새로운 IP 주소를 할당받았으며, 새 네트워크의 게이트웨이를 찾기 위해 새로운 ARP 요청을 보내는 것을 확인했습니다.</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ol>

                <h4>💡 문제 해결 및 성과</h4>
                <ul>
                    <li><strong>[문제]</strong>: UDP로 파일 전송 시, 패킷 유실 및 순서 뒤바뀜 현상으로 파일이 깨졌습니다.</li>
                    <li><strong>[해결]</strong>: TCP의 동작 원리를 참고하여, <strong>ACK 번호와 타임아웃 타이머, 윈도우(버퍼)를 직접 구현</strong>하여 RDT 프로토콜을 완성했습니다.</li>
                    <li><strong>[성과]</strong>: 라이브러리에 의존하지 않고 <strong>네트워크 프로토콜의 핵심(신뢰성, 흐름 제어)을 직접 구현</strong>해보며, CS 기본 지식의 실제 적용 능력을 향상시켰습니다.</li>
                </ul>
            </section>
            <!-- #################################### -->
            <!--   프로젝트 2 섹션 끝   -->
            <!-- #################################### -->

            <!-- 프로젝트 3: Prolog 에이전트 -->
            <section id="content-3" class="project-content hidden">
                <h2>Prolog 기반 학생 생활 시뮬레이션 에이전트</h2>
                <h3>논리형 언어 Prolog를 사용하여, 학생의 상태와 시간표에 따라 46시간의 행동을 자동으로 결정하고 최종 성과를 시뮬레이션하는 규칙 기반 에이전트를 구현했습니다.</h3>
                
                <p class="text-sm text-slate-500 mb-4">
                    <span class="font-medium">프로젝트 기간:</span> 202X.XX ~ 202X.XX (개인 프로젝트)
                </p>

                <h4>🛠️ 사용 기술</h4>
                <div>
                    <span class="tech-tag">Prolog</span>
                    <span class="tech-tag">SWI-Prolog</span>
                    <span class="tech-tag">Logic Programming</span>
                </div>

                <h4>📜 주요 구현 내용</h4>
                <ul>
                    <li><strong>Fact & Rule 정의</strong>: 학생의 5가지 상태(HP, Int, MP, Hunger, Project)를 `Fact`로, 행동 결정 로직을 `Rule`로 정의했습니다.</li>
                    <li><strong>우선순위 기반 행동 결정</strong>: `식사 > 수면 > 휴식 > 수업 > 프로젝트` 순서의 명확한 우선순위를 `decide_action` 규칙으로 구현했습니다.</li>
                    <li><strong>재귀적 시뮬레이션</strong>: `process_schedule` 규칙이 46시간을 재귀적으로 처리하며 매시간 상태 변화를 추적하고, 최종 Exam/Project 점수를 도출했습니다.</li>
                    <li><strong>Python과 비교 분석</strong>: 동일한 로직을 Python의 `if-elif-else` 문으로 구현해보며, 절차형 언어와 논리형 언어의 패러다임 차이점을 고찰했습니다.</li>
                </ul>

                <h4>💡 문제 해결 및 성과</h4>
                <ul>
                    <li><strong>[문제]</strong>: '최적의 스케줄'을 찾아야 하는 문제에서 Prolog의 접근법을 고민했습니다.</li>
                    <li><strong>[해결]</strong>: 이번 과제는 '최적 탐색'보다는 '정해진 우선순위'가 명확한 문제임을 파악하고, Prolog의 `->` 연산자(If-Then-Else)를 활용해 절차적 언어의 `if-elif` 구조를 효율적으로 모델링했습니다.</li>
                    <li><strong>[성과]</strong>: Python, C 등 절차형/객체지향 언어 외에 <strong>논리형 프로그래밍이라는 새로운 패러다임</strong>을 학습하고 적용했으며, 이를 통해 <strong>AI의 '규칙 기반 전문가 시스템'의 기본 원리</strong>를 이해했습니다.</li>
                </ul>

                <h4>🧠 AI 시대와 Prolog에 대한 고찰</h4>
                <div class="reflection-box">
                    <h5>1. 프로젝트에서 느낀 Prolog의 특징</h5>
                    <p class="mb-3">
                        이 프로젝트는 '어떻게(How)'가 명확한(식사 > 수면 > 휴식...) 절차적 문제였기에 Python의 `if-elif-else`와 큰 차이를 느끼지 못했습니다. 하지만 만약 "최종 점수를 최대화하는 최적의 스케줄 조합을 찾아라"라는 문제였다면, Prolog의 <strong>'자동 탐색'과 '논리 추론'</strong> 기능이 훨씬 강력했을 것입니다.
                    </p>

                    <h5>2. 현대 AI 시대에서 Prolog의 역할: "설명 가능한 뇌"</h5>
                    <p class="mb-3">
                        이 경험은 현대 AI의 과제와 일치합니다.
                    </p>
                    <ul class="list-disc list-inside mb-3 space-y-2">
                        <li><strong>통계적 AI (딥러닝)</strong>: 데이터에서 '패턴'을 학습합니다. 강력하지만 '왜'인지 알기 어려운 **'블랙박스(Black Box)'**입니다.</li>
                        <li><strong>심볼릭 AI (Prolog)**: 인간의 '지식'과 '규칙'으로 '논리'를 추론합니다. 근거가 명확하지만 스스로 학습하긴 어렵습니다.</li>
                    </ul>
                    <p class="mb-3">
                        AI가 성숙하며 이 둘을 결합한 **"신경-심볼릭 AI (Neuro-Symbolic AI)"**가 주목받고 있습니다. 딥러닝이 '직관'을 얻으면, Prolog가 '추론'을 수행하는 것입니다.
                    </p>
                    <h5>Prolog의 잠재적 역할:</h5>
                    <ul class="list-disc list-inside space-y-2">
                        <li><strong>설명 가능한 AI (XAI)</strong>: AI의 결정을 인간이 이해할 수 있는 '논리적 규칙'으로 설명합니다. (예: "A 처방은 '고혈압' 규칙 때문입니다.")</li>
                        <li><strong>지식 그래프 / 전문가 시스템</strong>: 복잡한 도메인 지식(법률, 의료)을 규칙으로 정의하여 AI의 실수를 방지합니다.</li>
                        <li><strong>고차원적 추론</strong>: 딥러닝이 "고양이다"라고 인식하면, Prolog가 "고양이는 포유류다"라는 지식을 연결해 더 깊은 추론을 가능하게 합니다.</li>
                    </ul>
                    <p class="mt-4 font-medium">
                        결론: 딥러닝이 AI의 강력한 '근육'이라면, Prolog는 AI의 행동 원칙과 논리를 제공하는 '두뇌의 이성' 역할을 할 수 있으며, 더 정교하고 안전한 AI를 위해 필요한 기술입니다.
                    </p>
                </div>
            </section>
        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const tabs = document.querySelectorAll('.nav-tab');
            const contents = document.querySelectorAll('.project-content');

            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const tabId = tab.getAttribute('data-tab');

                    // 모든 탭의 active-tab 클래스 제거
                    tabs.forEach(t => t.classList.remove('active-tab'));
                    // 클릭된 탭에 active-tab 클래스 추가
                    tab.classList.add('active-tab');

                    // 모든 컨텐츠 숨기기
                    contents.forEach(content => {
                        content.classList.add('hidden');
                    });

                    // 해당 탭의 컨텐츠 보이기
                    const activeContent = document.getElementById(`content-${tabId}`);
                    if (activeContent) {
                        activeContent.classList.remove('hidden');
                    }
                });
            });
        });
    </script>

</body>
</html>
