{
  "projects": [
    {
      "id": 1,
      "title": "TPC-H 벤치마크를 이용한 데이터베이스 성능 평가",
      "subtitle": "100GB 규모의 TPC-H 벤치마크 데이터를 생성하여, RDBMS와 NoSQL 데이터베이스 시스템 간의 성능을 비교 분석하고 성능 개선까지 시도한 팀 프로젝트입니다.",
      "period": "2024.09 ~ 2024.12 (팀 프로젝트)",
      "techStack": ["PostgreSQL", "MySQL", "Cassandra", "MongoDB", "AWS EC2", "Ubuntu OS"],
      "activities": [
        {
          "title": "1. 인프라 구축 및 확장 (AWS EC2)",
          "problem": "초기 단일 EC2 인스턴스(`t3a.xlarge`) 환경에서 100GB 데이터 처리 시, 컴퓨팅 자원 부족 문제에 직면했습니다.",
          "solution": "4개의 EC2 인스턴스로 확장하고, 인스턴스 사양을 `c5.4xlarge` 등으로 업그레이드하여 안정적인 테스트 환경을 구축했습니다."
        },
        {
          "title": "2. Cassandra Multi-Node 클러스터 구축",
          "goal": "데이터베이스 확장성(Scalability)을 실증적으로 분석하기 위해 4-Node Cassandra 클러스터를 구축했습니다.",
          "process": [
            "AWS 보안 그룹에서 클라이언트 포트(9042) 및 노드 간 통신 포트(7000)를 개방했습니다.",
            "`cassandra.yaml` 설정 파일에서 Seed 노드 IP를 지정하고 노드 간 `listen_address`를 설정하여 클러스터를 구성했습니다.",
            "`nodetool status` 명령어를 사용해 4개 노드가 모두 정상(Status=UN) 연결되었는지 확인했습니다."
          ]
        },
        {
          "title": "3. MongoDB 성능 이슈 분석 및 스키마 재설계",
          "problem": "MongoDB 환경에서 복잡한 TPC-H 쿼리 실행 시 'broken pipe' 및 'MaxTimeMSExpired' (4시간 이상 초과) 오류가 발생하며 쿼리가 실패했습니다.",
          "hypothesis": "정규화된 SQL 스키마를 그대로 MongoDB에 로드하여, 쿼리 수행 시 과도한 `$lookup` (SQL의 JOIN) 연산이 발생한 것을 원인으로 진단했습니다.",
          "attempt": "MongoDB의 Document 모델에 최적화하기 위해, 'supplier' 내부에 'nation'과 'region' 정보를 내장(Embedding)하는 비정규화(Denormalization) 스키마로 데이터를 재설계했습니다.",
          "conclusion": "스키마를 개선했음에도 쿼리 타임아웃이 재발생했으며, 이를 통해 TPC-H 벤치마크의 복잡한 관계형 조인 쿼리는 MongoDB의 Aggregation Framework에 부적합하다는 결론을 도출했습니다."
        },
        {
          "title": "4. MySQL 성능 튜닝 (후속 연구)",
          "problem": "100GB 데이터 로드 및 쿼리 중 서버 다운 등 불안정 문제가 발생하여, 초기 튜닝 시도(버퍼 풀 조정)가 유의미한 결과를 내지 못했습니다.",
          "retry": "10GB 데이터셋으로 환경을 재구성하여, `my.cnf` 파일의 `innodb_buffer_pool_size` (1G, 26G, 29G) 값을 변경하며 성능을 테스트했습니다.",
          "result": "버퍼 풀 크기를 1GB에서 26/29GB로 늘리자, 대규모 디스크 I/O를 유발하는 쿼리(Q17, Q20)의 실행 시간이 각각 1/3, 1/4 수준으로 단축되는 것을 확인했습니다.",
          "conclusion": "대용량 데이터 처리 시, 충분한 버퍼 풀 메모리 확보를 통한 디스크 I/O 감소가 성능 향상에 핵심적임을 입증했습니다."
        }
      ],
      "stats": [
        {
          "value": "67.95%",
          "label": "Cassandra Multi-Node 쿼리 시간 단축"
        },
        {
          "value": "최대 4배",
          "label": "MySQL 튜닝(Buffer Pool) 성능 향상"
        }
      ],
      "achievements": [
        {
          "title": "Cassandra 확장성 입증",
          "content": "Cassandra Multi-node(4대) 구성은 Single-node 대비 전체 쿼리 실행 시간을 67.95% 단축시켰습니다. 이는 병렬 처리 및 분산 아키텍처의 효율성을 명확하게 보여줍니다."
        },
        {
          "title": "RDBMS vs NoSQL 특성 비교",
          "items": [
            {
              "subtitle": "RDBMS (PostgreSQL, MySQL)",
              "content": "TPC-H의 복잡한 조인 및 집계 쿼리 실행에 강점을 보였습니다."
            },
            {
              "subtitle": "NoSQL (Cassandra, MongoDB)",
              "content": "Cassandra는 분산 환경의 병렬 처리 및 특정 필터링/집계 쿼리에 강점을 보였으나, MongoDB는 복잡한 관계형 쿼리 실행에 실패하며 한계를 보였습니다."
            }
          ]
        }
      ]
    },
    {
      "id": 2,
      "title": "TCP/UDP 기반 네트워크 응용 프로그램",
      "subtitle": "TCP/UDP를 이용해 기본 채팅부터 신뢰성 있는 파일 전송까지 구현하여 확인해보고, 네트워크 스캐너 기능까지 구현하여 네트워크에 대한 이해를 향상 시킨 프로젝트입니다.",
      "period": "2024.09 ~ 2024.12 (팀 프로젝트)",
      "techStack": ["Python","TCP", "UDP","WireShark"],
      "parts": [
        {
          "title": "Part 1. 기본 소켓 채팅 프로그램",
          "desc": "TCP/UDP 소켓 프로그래밍의 기본을 이해하고, 간단한 클라이언트-서버 채팅 GUI 프로그램을 구현했습니다.",
          "items": [
            "`socket` 라이브러리를 사용하여 TCP 서버/클라이언트 및 UDP 서버/클라이언트 소켓을 각각 생성하고 연결했습니다.",
            "TCP (연결 지향)와 UDP (비연결 지향) 프로토콜을 통해 양방향 텍스트 메시지 송수신 기능을 구현했습니다."
          ]
        },
        {
          "title": "Part 2. 신뢰성 있는 파일 전송 (RDT)",
          "desc": "1부의 채팅 프로그램에 파일 전송 기능을 추가하고, 특히 UDP의 비신뢰성을 극복하기 위한 RDT(Reliable Data Transfer) 프로토콜을 직접 구현했습니다.",
          "rdtTitle": "UDP 신뢰성 보장 (RDT)",
          "rdtItems": [
            {
              "subtitle": "Sliding Window (GBN/SR)",
              "content": "ACK 번호와 패킷 시퀀스 번호를 관리하는 슬라이딩 윈도우 메커니즘을 구현했습니다."
            },
            {
              "subtitle": "Timeout 및 재전송",
              "content": "ACK 수신 시간을 체크하고, 타임아웃 발생 시 해당 패킷을 재전송하여 데이터 유실을 방지했습니다."
            },
            {
              "subtitle": "패킷 버퍼링",
              "content": "수신 측에서 순서가 맞지 않는 패킷을 버퍼에 임시 저장하고, 연속된 패킷이 도착하면 파일에 순차적으로 쓰도록 구현했습니다."
            }
          ],
          "result": "TCP와 UDP 양쪽 프로토콜로 이미지, 텍스트 파일 등을 성공적으로 전송하고, 수신자의 폴더에 저장되는 것을 확인했습니다."
        },
        {
          "title": "Part 3. ARP 스캐너 및 모빌리티 분석",
          "desc": "'scapy' 라이브러리를 활용해 ARP 스캐너를 구현하고, 네트워크 환경 이동에 따른 IP 주소와 ARP 테이블의 변화를 분석했습니다.",
          "arpScanner": "지정된 IP 대역에 ARP Request 패킷을 전송하고, 수신된 ARP Reply를 분석하여 로컬 네트워크 내 활성 장치들의 IP와 MAC 주소 목록을 확보했습니다.",
          "mobilityTitle": "모빌리티 분석",
          "mobilityItems": [
            {
              "case": "Case 1 (같은 장소)",
              "content": "동일 AP에서 재연결 시, IP 주소가 변경되지 않았으며 기존 IP-MAC 매핑을 재확인하는 ARP 요청만 관찰되었습니다."
            },
            {
              "case": "Case 2 (장소 이동)",
              "content": "다른 AP로 이동하자, DHCP를 통해 새로운 IP 주소를 할당받았으며, 새 네트워크의 게이트웨이를 찾기 위해 새로운 ARP 요청을 보내는 것을 확인했습니다."
            }
          ]
        }
      ],
      "problemSolving": {
        "problem": "UDP로 파일 전송 시, 패킷 유실 및 순서 뒤바뀜 현상으로 파일이 깨졌습니다.",
        "solution": "TCP의 동작 원리를 참고하여, ACK 번호와 타임아웃 타이머, 윈도우(버퍼)를 직접 구현하여 RDT 프로토콜을 완성했습니다.",
        "achievement": "네트워크 프로토콜의 핵심(신뢰성, 흐름 제어)을 직접 구현해보며, CS 기본 지식의 실제 적용 능력을 향상시켰습니다."
      }
    }
  ]
}
